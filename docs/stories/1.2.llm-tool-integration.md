# Story 1.2: LLM Tool Integration

## Status
Approved

## Story

**As a** user,
**I want** the LLM to understand and respond to natural language requests for finding places and getting directions,
**so that** I can ask questions like "Find sushi restaurants near Senayan" or "How do I get from Jakarta to Bandung" and receive structured map results through the chat interface.

## Acceptance Criteria

1. Maps tools are properly registered with the existing OpenWebUI tool infrastructure
2. LLM can invoke maps functionality through function calling with proper parameter mapping
3. Tool specifications follow OpenWebUI patterns and integrate seamlessly with existing tool middleware
4. Natural language queries are correctly parsed and translated to appropriate maps API calls
5. Tool validation, authentication, and error handling integrate with existing OpenWebUI systems
6. Maps tools appear in the tool management interface and can be enabled/disabled
7. Tool responses are properly formatted for LLM consumption and chat display

## Tasks / Subtasks

- [ ] **Task 1: Maps Tool Module Setup** (AC: 1, 3)
  - [ ] Create maps tool module content following OpenWebUI tool patterns
  - [ ] Implement tool metadata with proper manifest and frontmatter
  - [ ] Create tool specifications that match existing tool infrastructure
  - [ ] Ensure compatibility with OpenWebUI tool loading mechanisms (Tools class pattern)

- [ ] **Task 2: Maps Function Specifications** (AC: 2, 4, 7)
  - [ ] Define `find_places` function with OpenAI function spec format
  - [ ] Define `get_directions` function with proper parameter validation
  - [ ] Define `place_details` function with structured output format
  - [ ] Implement function parameter validation using Pydantic models

- [ ] **Task 3: Tool Registration Integration** (AC: 1, 6)
  - [ ] Register maps tool with OpenWebUI tool system (programmatically or via admin interface)
  - [ ] Store tool content in database via Tools model
  - [ ] Ensure maps tools appear in admin tool interface
  - [ ] Implement proper access control integration

- [ ] **Task 4: LLM Function Calling Implementation** (AC: 2, 4)
  - [ ] Implement function handlers that call maps router endpoints
  - [ ] Add proper parameter mapping from LLM calls to API parameters
  - [ ] Integrate with existing tool calling middleware
  - [ ] Handle async execution patterns consistent with OpenWebUI

- [ ] **Task 5: Response Formatting & Error Handling** (AC: 5, 7)
  - [ ] Format maps API responses for LLM consumption
  - [ ] Implement comprehensive error handling for tool failures
  - [ ] Add logging and monitoring integration with existing systems
  - [ ] Ensure proper exception propagation through tool middleware

- [ ] **Task 6: Tool Validation & Security** (AC: 3, 5)
  - [ ] Implement input validation for all tool parameters
  - [ ] Integrate with existing OpenWebUI authentication systems
  - [ ] Add rate limiting integration for tool calls
  - [ ] Implement proper permission checking for maps access

- [ ] **Task 7: Natural Language Processing** (AC: 4)
  - [ ] Create tool descriptions that guide LLM on when to use maps functions
  - [ ] Implement parameter extraction helpers for location parsing
  - [ ] Add example usage patterns in tool specifications
  - [ ] Test natural language to function call translation

- [ ] **Task 8: Testing & Integration** (AC: 1, 2, 3, 4, 5, 6, 7)
  - [ ] Create unit tests for all tool functions and specifications
  - [ ] Test integration with existing tool middleware and calling system
  - [ ] Test LLM function calling with various natural language inputs
  - [ ] Verify tool management interface integration
  - [ ] Test error handling and edge cases

## Dev Notes

### Previous Story Dependencies
**Story 1.1 (Backend API Foundation)** must be completed first:
- Maps router endpoints must be available at `/maps/find_places`, `/maps/get_directions`, `/maps/place_details`
- Google Maps API integration must be functional
- Basic error handling and validation must be implemented

### Data Models

**Tool Specifications** [Source: backend/open_webui/utils/tools.py]:
```python
{
    "name": "find_places",
    "description": "Find places of interest using natural language search",
    "parameters": {
        "type": "object",
        "properties": {
            "location": {"type": "string", "description": "Current location or search center"},
            "query": {"type": "string", "description": "What to search for (e.g., 'restaurants', 'gas stations')"},
            "type": {"type": "string", "description": "Place type filter", "enum": ["restaurant", "gas_station", "hospital", "school"]},
            "radius": {"type": "integer", "description": "Search radius in meters", "default": 5000}
        },
        "required": ["location", "query"]
    }
}
```

**Function Response Format** [Source: docs/architect/4-agent-api-contracts.md]:
```python
{
    "places": [
        {
            "name": "Restaurant Name",
            "address": "Full Address",
            "lat": -6.2088,
            "lng": 106.8456,
            "place_id": "ChIJ...",
            "rating": 4.5,
            "open_now": True,
            "maps_url": "https://maps.google.com/..."
        }
    ],
    "status": "success",
    "message": "Found 5 places matching your search"
}
```

### API Integration Patterns

**Tool Module Structure** [Source: backend/open_webui/utils/plugin.py tool loading patterns]:
```python
# Tool module content for database storage
class Tools:
    """
    Maps Tool for Google Maps integration
    """
    
    async def find_places(
        self,
        location: str,
        query: str,
        type: Optional[str] = None,
        radius: int = 5000,
        __user__: dict = {},
        __id__: str = None
    ) -> dict:
        """Find places of interest using natural language search."""
        # Implementation calls maps router endpoints
        # Returns formatted response for LLM
        
    async def get_directions(
        self,
        origin: str,
        destination: str,
        mode: str = "driving",
        __user__: dict = {},
        __id__: str = None
    ) -> dict:
        """Get directions between two locations."""
        
    async def place_details(
        self,
        place_id: str,
        __user__: dict = {},
        __id__: str = None
    ) -> dict:
        """Get detailed information about a specific place."""
```

**Tool Registration Pattern** [Source: backend/open_webui/routers/tools.py]:
- Tool content stored in database via `Tools.insert_new_tool`
- Tool modules loaded dynamically via `load_tool_module_by_id`
- Specifications generated via `get_tool_specs`
- Must implement Tools class with function methods

### Component Specifications

**Tool Module**: Python content stored in database via Tools model
**Tool Integration**: Existing OpenWebUI tool infrastructure
**Function Calling**: OpenAI-compatible function specs
**Middleware**: Integration with `chat_completion_tools_handler`

### File Locations
Based on existing OpenWebUI tool infrastructure:
- **Tool Content**: Python module content for database storage (not static file)
- **Tool Specs**: Generated dynamically via `get_tool_specs`
- **Integration**: Existing `backend/open_webui/utils/tools.py` and middleware
- **Tests**: `backend/open_webui/test/tools/test_maps_tool.py`
- **Registration**: Via existing tool management system (`/routers/tools.py`)

### Testing Requirements

**Test File Locations**: 
- Tool module tests: `backend/open_webui/test/tools/test_maps_tool.py`
- Tool registration tests: `backend/open_webui/test/routers/test_maps_tool_registration.py`
- Integration tests: `backend/open_webui/test/utils/test_maps_integration.py`
- Function calling tests: `backend/open_webui/test/middleware/test_maps_tools.py`

**Test Standards**: 
- Follow existing OpenWebUI tool testing patterns
- Mock maps router endpoints for unit tests
- Test LLM function calling integration
- Test tool registration and management
- Test error handling and validation
- Integration with existing authentication systems

**Testing Frameworks**: 
- pytest (existing OpenWebUI standard)
- FastAPI TestClient for endpoint testing
- unittest.mock for mocking maps API calls and router responses

**Specific Testing Requirements**: 
- Test all three tool functions with valid and invalid inputs
- Test natural language parameter extraction and mapping
- Test integration with existing tool middleware and calling system
- Test tool registration and management interface integration
- Test authentication and permission checking
- Test error handling for maps router failures
- Test response formatting for LLM consumption

### Technical Constraints

**Tool Infrastructure Requirements** [Source: backend/open_webui/utils/tools.py]:
- Must follow OpenWebUI tool module patterns
- Function specs must be OpenAI-compatible
- Integration with existing tool calling middleware
- Support for user authentication and permissions

**LLM Integration Requirements** [Source: backend/open_webui/utils/middleware.py]:
- Tools must integrate with `chat_completion_tools_handler`
- Support for both native and custom function calling modes
- Proper error handling and response formatting
- Integration with existing tool validation systems

**Security Requirements** [Source: docs/architect/5-security-reliability.md]:
- All tool calls must go through existing authentication
- Input validation and sanitization required
- Integration with existing rate limiting systems
- Proper logging and audit trail

### Natural Language Examples

**Example User Queries and Expected Function Calls**:
- "Find sushi restaurants near Senayan" → `find_places(location="Senayan", query="sushi restaurants", type="restaurant")`
- "Show me gas stations within 2km" → `find_places(location="current", query="gas stations", type="gas_station", radius=2000)`
- "How do I get from Jakarta to Bandung by car?" → `get_directions(origin="Jakarta", destination="Bandung", mode="driving")`
- "Tell me more about place ChIJ123..." → `place_details(place_id="ChIJ123...")`

**Tool Description Guidelines**:
- Clear, specific descriptions that guide LLM usage
- Parameter descriptions with examples
- Enumerated values for constrained parameters
- Default values for optional parameters

## Change Log

| Date | Version | Description | Author |
|------|---------|-------------|---------|
| 2025-01-27 | 1.0 | Initial story creation based on corrected integration approach | Bob (Scrum Master) |

## Dev Agent Record

*This section will be populated by the development agent during implementation*

### Agent Model Used
*To be filled by dev agent*

### Debug Log References
*To be filled by dev agent*

### Completion Notes List
*To be filled by dev agent*

### File List
*To be filled by dev agent*

## QA Results

*Results from QA Agent QA review will be populated here after implementation* 